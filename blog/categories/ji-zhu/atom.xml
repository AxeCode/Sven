<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 技术 | 乐正]]></title>
  <link href="http://yuez.me/blog/categories/ji-zhu/atom.xml" rel="self"/>
  <link href="http://yuez.me/"/>
  <updated>2015-07-18T09:40:22+08:00</updated>
  <id>http://yuez.me/</id>
  <author>
    <name><![CDATA[乐正]]></name>
    <email><![CDATA[zgs225@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用VirtualBox和Vagrant搭建Linux开发环境]]></title>
    <link href="http://yuez.me/vagrant-install-linux/"/>
    <updated>2015-07-18T09:36:00+08:00</updated>
    <id>http://yuez.me/vagrant-install-linux</id>
    <content type="html"><![CDATA[<p>1.下载并安装vagrant和virtualBox.(VB在前，vagrant在后，以防止vagrant检测不到VB)。</p>

<p>2.启动VirtualBox修改虚拟机默认保存路径，改为其他盘，以节省C盘空间。</p>

<p>3.在任意目录新建文件夹，假设为<code>d:/vm</code>，启动windows命令行，cd至该目录下：此处以ubuntu/trusty64 box为例。更多系统可以搜索 <a href="https://vagrantcloud.com">https://vagrantcloud.com</a>。trusty64为ubuntu14.04 64位服务器版，比较纯净。命令行中输入    <code>vagrant init ubuntu/trusty64</code></p>

<p>4.按照提示输入<code>vagrant up</code>。该命令执行后vagrant会去自动下载指定的系统镜像，并且帮你在VirtualBox中建立一个新的虚拟机。命令执行成功虚拟机将会启动。</p>

<p>5.<code>d:/vm</code>下Vagrantfile即为当前box的配置文件。编辑“Vagrantfile”文件，找到<code>config.vm.network "private_network", ip: "192.168.33.10"”</code>所在的行，将其前面的“#”号去掉。重新加载这个box，使得配置生效。输入命令： <code>vagrant reload</code>。执行完以上操作后我们就可以通过vagrant配置文件中使指定的ip地址来访问到该虚拟机了。</p>

<p>6.接着我们要通过ssh的方式来链接到我们刚刚建立好的虚拟机上。 输入命令：<code>vagrant ssh</code>。vagrant会提示连接地址端口用户名和密钥位置。这里推荐使用 xshell 这个ssh客户端,假设已经装好,运行xshell,新建会话，输入host和port确定。第一次登陆须输入用户名，此处为vagrant,接着用户验证，选择“Public Key”，然后点击浏览按钮选择“文件”，然后根据vagrant之前给你的信息找到key文件。点击确定后即可成功连接到你的虚拟机。</p>

<p>7.请务必注意，给您的电脑关机之前，一定要用windows的命令行执行<code>vagrant halt</code>来关闭你的虚拟机，否则很有可能要重新装过。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[什么是线程]]></title>
    <link href="http://yuez.me/shen-me-shi-xian-cheng/"/>
    <updated>2015-06-01T21:44:33+08:00</updated>
    <id>http://yuez.me/shen-me-shi-xian-cheng</id>
    <content type="html"><![CDATA[<blockquote><p>要成就一个复杂的系统，各部分必须分工明确，各司其职。 —— 《人工科学》</p></blockquote>

<h2>线程和进程</h2>

<p>在上篇文章中（<a href="/jin-cheng-miao-shu-he-kong-zhi/">进程描述和控制</a>），提出的进程概
念包含两个特点：</p>

<ul>
<li><p><strong>资源所有权</strong>：一个进程拥有包括一个存放进程映像的虚拟地址空间。一个进程总是拥
有对于资源的控制或所有权。操作系统提供对于资源访问的保护功能。</p></li>
<li><p><strong>调度/执行</strong>：一个进程具有一个执行状态和一个被分配的优先级，它是一个可以被操
作系统调度和分派的实体。</p></li>
</ul>


<p>分派的单位通常称为线程或轻量级进程；而拥有资源所有权的单位通常仍称为进程或者任务。</p>

<h4>多线程</h4>

<p><strong>多线程</strong>是指在操作系统单个进程内支持多个并发执行路径的能力。对应的每个进程只有
一个线程在执行的称为<strong>单线程方法</strong>。</p>

<p>在多线程环境中，进程被定义成资源分配的单位和一个被保护的单位。在一个进程中，可能
有一个或者多个线程，每个线程有：</p>

<ul>
<li>线程执行状态（运行、就绪等）</li>
<li>在未运行时保存的线程上下文。</li>
<li>一个执行栈。</li>
<li>用于每个线程局部变量的静态存储空间。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第一次与 Arduino 交互]]></title>
    <link href="http://yuez.me/di-yi-ci-yu-arduino-jiao-hu/"/>
    <updated>2015-05-31T21:01:21+08:00</updated>
    <id>http://yuez.me/di-yi-ci-yu-arduino-jiao-hu</id>
    <content type="html"><![CDATA[<p>这是一个比较简单的实验，不过好歹也是让 Arduino 接受外界电子元件的输入值了。这是
套互动交通灯的实验，Arduino 等待行人按下按钮，这样行车灯会变红，行人灯会变绿。</p>

<h2>需要的电子元件</h2>

<ul>
<li>LED 灯（2红，2绿，1黄）</li>
<li>100Ω 电阻</li>
<li>10KΩ 高阻值电阻（用于下拉电阻）</li>
<li>按钮（有时供应商称之为微动开关）</li>
<li>面包板与导线</li>
</ul>


<h2>代码回顾</h2>

<pre><code class="c">int carRed    = 12;
int carGreen  = 10;
int carYellow = 11;

int pedRed    =  8;
int pedGreen  =  9;

int buttonPin =  2;

int crossTime = 5000;
unsigned long changeTime; // Time of press button

void setup() {
  pinMode(carRed,    OUTPUT);
  pinMode(carGreen,  OUTPUT);
  pinMode(carYellow, OUTPUT);

  pinMode(pedRed,    OUTPUT);
  pinMode(pedGreen,  OUTPUT);

  pinMode(buttonPin, INPUT);

  digitalWrite(carGreen, HIGH);
  digitalWrite(pedRed, HIGH);
}

void loop() {
  int state = digitalRead(buttonPin);

  if (state == HIGH &amp;&amp; (millis() - changeTime) &gt; 5000)
    changeLights();
}

void changeLights() {
  digitalWrite(carGreen, LOW);
  digitalWrite(carYellow, HIGH);
  delay(2000);

  digitalWrite(carYellow, LOW);
  digitalWrite(carRed, HIGH);
  delay(1000);

  digitalWrite(pedRed, LOW);
  digitalWrite(pedGreen, HIGH);
  delay(crossTime);

  for (int i = 0; i &lt; 10; i ++) {
    digitalWrite(pedGreen, HIGH);
    delay(250);
    digitalWrite(pedGreen, LOW);
    delay(250);
  }

  digitalWrite(pedRed, HIGH);
  delay(500);

  digitalWrite(carYellow, HIGH);
  digitalWrite(carRed, LOW);
  delay(1000);
  digitalWrite(carGreen, HIGH);
  digitalWrite(carYellow, LOW);

  changeTime = millis();
}
</code></pre>

<p>这次使用了一个能存储大数字的数据类型</p>

<pre><code class="c">unsigned long chageTime;
</code></pre>

<p>由于 Arduino 使用的 Atemga 32 只有很小的内存，所以合理分配与使用内存在这之上就显
得非常重要。</p>

<p>接下来就是让 Arduino 读取按钮输出值了，</p>

<pre><code class="c">pinMode(buttonPin, INPUT);
</code></pre>

<p>这句代码让 Arduino 将按钮所在的引脚设置为 <code>Input</code> 模式。在程序循环中，使用</p>

<pre><code class="c">int state = digitalRead(buttonPin);
</code></pre>

<p>来检查引脚的状态。</p>

<h2>硬件回顾</h2>

<p>本次与 Arduino 交互的元件是按钮，或者叫开关。按钮不是之间连接在电源线和引脚之间
的，在按钮和地之间有一个电阻，这个电阻叫<strong>下拉电阻</strong>。对应的还有<strong>上拉电阻</strong>，它
们对保证按钮正常工作是非常重要的。</p>

<h4>逻辑状态</h4>

<p><strong>逻辑电路</strong>是一种只有开、关两种状态的电路，用布尔数0和1表示。电路处于关状态时，
输出端的电压接近0V。电路处于开状态时用高电平表示，输出端接近于电源供电电压。</p>

<p>如果不能确定状态接近所需要的电压，这部分电路可以被认为是<strong>浮动的</strong>（既不是高电平
，也不是低电平。），这种浮动也被称为电子噪声。电子噪声被随即的解释为0或者1。</p>

<p>上拉电阻或下拉电阻可用来保证状态确定为高或低。</p>

<h4>下拉电阻</h4>

<p>如左图：</p>

<p><img class="lazy no-shadow" data-original="/photos/dianzu.png" width="640" height="200" title="下拉电阻和上拉电阻" alt="下拉电阻和上拉电阻"></p>

<p>如果按钮被按下，电流以电阻最小的路径在5V 端与输入引脚之间流过。 当按钮没有被按下
时，输入引脚通过100KΩ 电阻接地。如果没有这个电阻，当按钮没有被按下时，这个引脚将
不连接任何东西，因此它的电压是在 0V 和 5V 之间浮动。在这个电路中，当按钮没有被按
下输入将总是接地的，或者是0V，当按钮被按下时它将指向5V端。</p>

<h4>上拉电阻</h4>

<p>如右图：</p>

<p><img class="lazy no-shadow" data-original="/photos/dianzu.png" width="640" height="200" title="下拉电阻和上拉电阻" alt="下拉电阻和上拉电阻"></p>

<p>交换下拉电阻和开关的位置，现在电阻变成了上拉电阻。当按钮没有被按下时，输入引脚通
过上拉电阻接到5V端，所以引脚上总是高电平。当按钮被按下时，通过限流电阻的路径引脚
接地，所以引脚被拉向地或者低电平状态。如果没有5V端和地之间的电阻，电路将被短路，
这将损坏电路或电源。上拉电阻在数字电路中应用更广泛。</p>

<p>上拉电阻在数字电路中经常用来保证输入保持高电平。</p>

<h4>Arduino 内部的上拉电阻</h4>

<p> Arduino 内部包含了上拉电阻。它连接在引脚上，阻值为20KΩ，使用时需要通过软件激活。</p>

<pre><code class="c">pinMode(pin, INPUT);
digitalWrite(pin, HIGH);
</code></pre>

<p>同理，当一个输出脚为 HIGH 时，转换这个引脚到 INPUT 模式，那么内部上拉电阻将激活。</p>

<h2>电位计与从模拟引脚读值</h2>

<h4>电位计</h4>

<p>电位计就是一个可调节电阻，调解范围从0到一个设定的值。电位计有三个引脚。若只连接
两个引脚，电位计可变为一个可变电阻。通过连接三个引脚，并为其提供电压，它将称为
一个分压器。</p>

<p>电位计提供了一种在0和设定的最大值之间调整数值的方法。</p>

<h4>模拟引脚读值</h4>

<p>Arduino有6个模拟输入/输出引脚，每个引脚带有一个10位模/数转换器。这意味着模拟引脚
能够读取0V 到 5V之间的电压，用0到1023之间的正数代表0V 到 5V之间的电压。每个分度
表示 5V / 1024 电压，即每个分度是4.9mV。</p>

<p>通过直接读取电位计引脚数值到ledDelay这个变量中：</p>

<pre><code class="c">byte potPin = 2; // 电位计连接到的模拟引脚
int ledDelay = analogRead(potPin);
</code></pre>

<p>注意：模拟引脚不需要像数字引脚一样设置输入或输出模式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino 学习笔记——LED 闪烁实验中隐含的简单原理]]></title>
    <link href="http://yuez.me/arduino-xue-xi-bi-ji-led-shan-shuo-shi-yan-zhong-yin-han-de-jian-dan-yuan-li/"/>
    <updated>2015-05-27T08:52:24+08:00</updated>
    <id>http://yuez.me/arduino-xue-xi-bi-ji-led-shan-shuo-shi-yan-zhong-yin-han-de-jian-dan-yuan-li</id>
    <content type="html"><![CDATA[<p>我是软件出身，但是许久以前便对硬件充满了兴趣，终于在最近买了一套 Arduino 基础开
发套件，希望能在硬件上学习一些知识。</p>

<p>几乎所有单片机学习的第一个实验都是<code>blink</code>，在这个小小的实验中也蕴含着一些我不知
道的电子电路知识，所以记录下在这个实验中所学习的知识，方便回顾整理。</p>

<h2>代码回顾</h2>

<pre><code class="c blink.ino">int ledPin = 10

void setup() {
  pinMode(ledPin, OUTPUT);
}

void loop() {
  digitalWrite(ledPin, HIGH);
  delay(1000);
  digitalWrite(ledPin, LOW);
  delay(1000);
}
</code></pre>

<p>这一段类似 C 的 Arduino 代码对于软件出身的我来说并不难理解。但是，这里要注意的是
Arduino 程序必须包含 <code>setup()</code> 和 <code>loop()</code> 两个函数，否则它将不能工作。顾名思义，
前者只在程序开始时运行一次，一般做初始化用，如设置引脚形式，设置波特率等等。后者
则是在程序中循环执行的，是主要的过程函数。</p>

<p>在这段代码的 <code>setup()</code> 函数中，只执行了一句代码：<code>pinMode(ledPin, OUTPUT)</code>，它告
诉 Arduino 设置引脚的模式为输出模式。由此易知，对应的应该还有一个 <code>INPUT</code> 的输入
模式。</p>

<p>在 <code>loop()</code> 函数中，让 LED 以一秒的频率闪烁，主要依靠 <code>digitalWrite</code> 和 <code>delay</code>
函数。其中，<code>digitalWrite(ledPin, HIGH)</code> 告诉数字引脚打开电源，<code>delay(1000)</code>让程
序暂停1秒，而 <code>digitalWrite(ledPin, LOW)</code> 则要求数字引脚关闭电源。</p>

<h2>硬件回顾</h2>

<p>在 LED 闪烁实验中，用到的硬件有：</p>

<ul>
<li>面包板</li>
<li>5mm LED</li>
<li>220Ω 电阻（或者其他适合你 LED 的数值）</li>
<li>跳线（也称面包线）</li>
</ul>


<h4>面包板</h4>

<p>面包板是一个可重复使用的非焊接单元，用于制作一个电子线路原型或者线路设计实验。这
个板在一个栅格中有一系列的孔，在板子背面，这些孔通过两条导电金属条相连。 如图：</p>

<p><img class="lazy no-shadow" data-original="/photos/breadboard.jpg" width="640" height="200" title="面包板排列" alt="面包板排列"></p>

<h4>电阻</h4>

<p>电阻会对电流产生一定的阻力，引起它两端的电压下降。在我的 LED 闪烁实验里面，数字
引脚输出5V、40mA 直流电，而我的 LED 需要的是2V、35mA 电流，因此我需要一个电阻降
 低电压和电流。</p>

<p> 计算需要的电阻阻值的公式是：</p>

<p>R = (V<sub>S</sub> - V<sub>L</sub>) / I</p>

<p>就是用电源电压减去 LED 电压除以 LED 电流。</p>

<p>那么怎样找到所需要的阻值的电阻呢？电阻使用色环代码表示电阻阻值的大小。</p>

<table>
<thead>
<tr>
<th>颜色 </th>
<th> 1st </th>
<th> 2nd </th>
<th> 3rd(幂)         </th>
<th> 4th(误差)</th>
</tr>
</thead>
<tbody>
<tr>
<td>黑色 </td>
<td>  0  </td>
<td>  0  </td>
<td> x10<sup>0</sup> </td>
<td></td>
</tr>
<tr>
<td>棕色 </td>
<td>  1  </td>
<td>  1  </td>
<td> x10<sup>1</sup> </td>
<td> +/- 1%</td>
</tr>
<tr>
<td>红色 </td>
<td>  2  </td>
<td>  2  </td>
<td> x10<sup>2</sup> </td>
<td> +/- 2%</td>
</tr>
<tr>
<td>橘黄 </td>
<td>  3  </td>
<td>  3  </td>
<td> x10<sup>3</sup> </td>
<td></td>
</tr>
<tr>
<td>黄色 </td>
<td>  4  </td>
<td>  4  </td>
<td> x10<sup>4</sup> </td>
<td></td>
</tr>
<tr>
<td>绿色 </td>
<td>  5  </td>
<td>  5  </td>
<td> x10<sup>5</sup> </td>
<td> +/- 0.5%</td>
</tr>
<tr>
<td>蓝色 </td>
<td>  6  </td>
<td>  6  </td>
<td> x10<sup>6</sup> </td>
<td> +/- 0.25%</td>
</tr>
<tr>
<td>紫色 </td>
<td>  7  </td>
<td>  7  </td>
<td> x10<sup>7</sup> </td>
<td> +/- 0.1%</td>
</tr>
<tr>
<td>灰色 </td>
<td>  8  </td>
<td>  8  </td>
<td> x10<sup>8</sup> </td>
<td> +/- 0.05%</td>
</tr>
<tr>
<td>白色 </td>
<td>  9  </td>
<td>  9  </td>
<td> x10<sup>9</sup> </td>
<td></td>
</tr>
<tr>
<td>金色 </td>
<td>     </td>
<td>     </td>
<td> x10<sup>-1</sup></td>
<td> +/- 5%</td>
</tr>
<tr>
<td>银色 </td>
<td>     </td>
<td>     </td>
<td> x10<sup>-2</sup></td>
<td> +/- 10%</td>
</tr>
<tr>
<td>无   </td>
<td>     </td>
<td>     </td>
<td>                 </td>
<td> +/- 20%</td>
</tr>
</tbody>
</table>


<h4>LED</h4>

<p>LED 是一个标准的发光二极管。二极管是一种器件，值允许电流从一个方向流进。二极管用
来防止在电路中意外地将电流和地连接以至于损坏其他元件。</p>

<p>LED 的引脚的长度不同，长的一边为正极，需要连接电源；短的一边为负极，需要接地。给
LED 串联一个电阻是必要的，以确保提供给 LED 正确的电流。</p>

<h2>总结</h2>

<p>实验虽然简单，确也有许多我不曾知道的知识点。希望自己能坚持下去，完成对于 Arduino
的学习。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis 基础教程]]></title>
    <link href="http://yuez.me/redis-ji-chu-jiao-cheng/"/>
    <updated>2015-05-26T10:46:25+08:00</updated>
    <id>http://yuez.me/redis-ji-chu-jiao-cheng</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>Redis 是一个键值存储仓库，经常被称为 NoSQL 数据库。键值存储仓库的本质是有能力按
照一个键映射一个值的方式存储一些数据，然后你可以只通过这个键寻找到你之前通过这个
键存储的值。我们可以使用命令<code>SET</code>将值『fido』存储在键『server:name』中：</p>

<pre><code class="ruby">SET server:name "fido"
</code></pre>

<p>Redis 将会把我们的数据永久存储。于是，我们可以假设这样询问 Redis 数据库：键 server:name
对应的值是什么？ 然后，Redis 会返回『fido』。</p>

<pre><code>GET server:name # =&gt; "fido"
</code></pre>

<p>下面列出了一些其他常用的命令：</p>

<ul>
<li><code>DEL</code>   根据给定的键，删除相应的键值关系</li>
<li><code>SETNX</code> 当且仅当给定键没有指定值的时候，才设定相应的键值对</li>
<li><code>INCR</code>  将数字递增</li>
</ul>


<pre><code>SET  connection 10
INCR connection # =&gt; 11
INCR connection # =&gt; 12
DEL  connection
INCR connection # =&gt; 1
</code></pre>

<h2>递增</h2>

<p>对于 <code>INCR</code> 命令，我们有一些特别的事情要说明。Redis 为什么会提供一个自己很简单就
能实现的功能呢？就像下面这么简单：</p>

<pre><code>x = GET count
x += 1
SET count x
</code></pre>

<p>然而问题是，这种递增操作只能用于单客户端上。看一下，如果两个客户端同时执行这样
的操作会发生什么：</p>

<ol>
<li>客户端 A 读取值 x 为10</li>
<li>客户端 B 读取值 x 为10</li>
<li>客户端 A 写 x 的值为11</li>
<li>客户端 B 写 x 的值为11</li>
</ol>


<p>我们希望 x 的值为12，但是真实的 x 的值仅仅是11，这是因为你自己定义的递增操作不是
一个原子性操作。使用 Redis 的 <code>INCR</code> 命令可以防止这样的事情发生， 因为它是一个原
子性操作。Redis 为许多不同类型的数据提供了类似的原子性操作。</p>

<h2>过期</h2>

<p>Redis 可以使用命令 <code>EXPIRE</code> 和 <code>TTL</code>，能让一个键值对只存在于指定的时间段内。</p>

<pre><code>SET resource:lock "Redis Demo"
EXPIRE resource:lock 120
</code></pre>

<p>这会导致键 resource:lock  会在120s 后被删除，你可以使用 <code>TTL</code> 去查看一个键还能存
在多少时间：</p>

<pre><code>TTL resource:lock # =&gt; 120

# after 122s later
TTL resource:lock # =&gt; -2
</code></pre>

<p>这里的 -2 是指 resource:lock 已经不存在了，如果返回值是 -1 说明这个键永远不会过
期。注意：当你使用 <code>SET</code> 重新设置一个键， 它对应的 <code>TTL</code> 就会被重置。</p>

<pre><code>SET resource:lock "Redis demo 1"
EXPIRE resource:lock 120
TTL resource:lock # =&gt; 119
SET resoource.lock "Redis demo 2"
TTL resource:lock # =&gt; -1
</code></pre>

<h2>列表</h2>

<p>此外，Redis 也支持一些更复杂的数据结构。我们第一个会看的是列表。一个列表是一系列
有序的值。与数组有关的一系列操作是：<code>RPUSH</code>, <code>LPUSH</code>, <code>LLEN</code>, <code>LRANGE</code>, <code>LPOP</code>和
<code>RPOP</code>。列表和普通的值一样，可以被直接使用。</p>

<ul>
<li><code>RPUSH</code> 将值添加到列表的末尾</li>
</ul>


<pre><code>RPUSH friends "Alice"
RPUSH friedns "Joe"
</code></pre>

<ul>
<li><code>LPUSH</code> 将值添加到列表的开始</li>
</ul>


<pre><code>LPUSH friends "Sam"
</code></pre>

<ul>
<li><code>LRANGE</code>是从列表中去一个指定范围的子集。它通过你想取的范围的第一个元素的下标和
最后一个元素的下标作为参数。将 -1 作为参数意味着取值到列表的最后。</li>
</ul>


<pre><code>LRANGE friends 0 -1 # =&gt; 1) "Sam", 2) "Alice", 3) "Joe"
LRANGE friends 0  1 # =&gt; 1) "Sam", 2) "Alice"
LRANGE friends 1  2 # =&gt; 1) "Alice", 2) "Joe"
</code></pre>

<ul>
<li><code>LLEN</code> 返回指定列表的长度</li>
</ul>


<pre><code>LLEN friends # =&gt; 3
</code></pre>

<ul>
<li><code>LPOP</code> 从列表中删除第一个元素，并将它作为返回值</li>
</ul>


<pre><code>LPOP friends # =&gt; "Sam"
</code></pre>

<ul>
<li><code>RPOP</code> 从列表中删除最后一个元素，并将它作为返回值</li>
</ul>


<pre><code>RPOP friends # =&gt; "Joe"
</code></pre>

<p>注意看现在的列表：</p>

<pre><code>LLEN friends # =&gt; 1
LRANGE friends 0 -1 # =&gt; 1) "Alice"
</code></pre>

<h2>集合</h2>

<p>接下来我们要看的数据结构是集合。集合和列表类似，但是集合中元素是无序且不能重复的。
和集合有关的一些重要的命令是：<code>SADD</code>, <code>SREM</code>, <code>SISMEMBER</code>, <code>SMEMBERS</code> 和 <code>SUNION</code>.</p>

<ul>
<li><code>SADD</code> 将给定的值添加到集合中</li>
</ul>


<pre><code>SADD superpowers "flight"
SADD superpowers "x-ray vision"
SADD superpowers "reflexes"
</code></pre>

<ul>
<li><code>SREM</code> 从集合中移除指定的值</li>
</ul>


<pre><code>SREM superpowers "reflexes"
</code></pre>

<ul>
<li><code>SISMEMBER</code> 检查一个值是否在集合中，返回0不在，返回1在。</li>
</ul>


<pre><code>SISMEMBER superpowers "flight" # =&gt; 1
SISMEMBER superpowers "reflexes" # =&gt; 0
</code></pre>

<ul>
<li><code>SMEMBERS</code> 返回集合中所有的元素</li>
</ul>


<pre><code>SMEMBERS superpowers # =&gt; 1) "flight", 2) "x-ray vision"
</code></pre>

<ul>
<li><code>SUNION</code> 合并两个或者更多个集合，并且将所有的元素返回。</li>
</ul>


<pre><code>SADD birdpowers "pecking"
SADD birdpowers "flight"
SUNION superpowers birdpowers # =&gt; 1) "pecking", 2) "flight", 3) "x-ray vision"
</code></pre>

<h2>可排序集合</h2>

<p>集合是一个非常有用的数据类型，但是因为它是无序的，所以因此会导致很多的问题。因此
Redis 1.2 开始添加了可排序集合。可排序集合和标准的集合类似，只是添加了一个分数和
集合中的元素相关联。这个分数用来给元素排序。</p>

<pre><code>ZADD hackers 1940 "Alan Kay"
ZADD hackers 1906 "Grace Hopper"
ZADD hackers 1954 "Wang Zhi He"
ZADD hackers 1988 "Li Feng"

ZRANGE hackers 1, 3 # =&gt; 1) "Alan Kay", 2) "Grace Hopper", 3) "Wang Zhi He"
</code></pre>

<h2>哈希表</h2>

<p>除了字符串、列表、集合之外，Redis 还能储存一种类型的数据————哈希表。哈希表将两个
字符串类型的值映射在一起，它是最好的用来表示对象的数据结构。</p>

<pre><code>HSET user:1000 name "John Smith"
HSET user:1000 email "john.smith@google.com"
HSET user:1000 password "public"
</code></pre>

<p>使用命令 <code>HGETALL</code> 获得保存的数据</p>

<pre><code>HGETALL user:1000
</code></pre>

<p>我们也可以一起行设置多个域</p>

<pre><code>HMSET user:1001 name "Zack Lee" email "zack.lee@facebook.com" password "public"
</code></pre>

<p>我们也可以只获取特定域的值：</p>

<pre><code>HGET user:1001 name # =&gt; "Zack Lee"
</code></pre>

<p>数字类型的值在哈希表里面有一些方便的原子性的递增方法：</p>

<pre><code>HSET user:1000 visits 10
HINCRBY user:1000 visits 1  # =&gt; 11
HINCRBY user:1000 visits 10 # =&gt; 21
HDEL    user:1000 visits
HINCRBY user:1000 visits 1  # =&gt; 1
</code></pre>

<p>关于哈希表的完整命令列表，请查看<a href="http://redis.io/commands#hash">官方文档</a></p>

<p>更多关于 Redis 文档:</p>

<ul>
<li><a href="http://redis.io/documentation">Redis官方文档</a></li>
<li><a href="http://redis.io/commands">命令参考</a></li>
<li><a href="http://redis.io/topics/data-types-intro">Redis 中数据类型介绍</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
